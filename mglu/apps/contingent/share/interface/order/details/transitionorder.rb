##
## Generated by details-generator. Do not edit!
##

require 'interface/order/details/common'
require 'expression'

class DetailsForTransitionOrder
	extend DetailsCommon

	CONDITIONS = [
		DetailsCommon::Condition.new('contract', {"study_type_id"=>Classifier::StudyType::CONTRACT}),
		DetailsCommon::Condition.new('foreign', {"citizenship_id"=>[4, 5, 6, 7]}),
		DetailsCommon::Condition.new('disabled', {"category"=>:disabled})
	]

	def self.has_order?
		true
	end

	def self.init_order(o)
		attributes = o.attributes.dup
		attributes['hide_study_type'] = 1
		attributes['hide_disabled'] = 1
		attributes.each_pair { |k,v| o.attributes[k] = v }
		o.save
	end

	def self.fix_order(o)
		attributes = o.attributes.dup
		attributes
	end

	def self.render_order(o, tmpl)
		attributes = fix_order(o)
		tmpl.vacations = attributes['vacations']
	end

	def self.save_order(o, params)
		attributes = o.attributes.dup
		attributes['vacations'] = params["vacations"].enabled?
		attributes.each_pair { |k,v| o.attributes[k] = v }
		o.save
	end

	def self.has_student?(paragraph)
		[1].member? paragraph
	end
	
	def self.init_student(o, eid, paragraph)
		attributes = o.get_student_attributes(eid)
		case paragraph
		when 1
		end
		o.set_student_attributes(eid, attributes)
	end
	
	def self.fix_student(o, eid, paragraph, attributes)
		attributes = attributes.dup
		case paragraph
		when 1
			attributes['excuse'] ||= Proc.new { 'уважительная' }.call
		end
		attributes
	end
	
	def self.render_student(o, eid, paragraph, tmpl)
		attributes = fix_student(o, eid, paragraph, o.get_student_attributes(eid))
		case paragraph
		when 1
			tmpl.liabilities = attributes['liabilities']
			tmpl.excuse = attributes['excuse']
			tmpl.deadline = attributes['deadline']
		end
	end
	
	def self.save_student(o, eid, paragraph, params)
		attributes = o.get_student_attributes(eid)
		case paragraph
		when 1
			collect_row = Proc.new { |index|
				row = {}
				row['subject'] = params["liabilities_subject_#{index}"]
				row['type'] = params["liabilities_type_#{index}"]
				row
			}
			attributes['liabilities'] = []
			i = 0
			while (keep = params["keep_liabilities_#{i}"])
				attributes['liabilities'] << collect_row.call(i) if keep == '1'
				i += 1
			end
			attributes['liabilities'] << collect_row.call('new') if params['keep_liabilities_new'] == '1'
			attributes['excuse'] = params["excuse"]
			attributes['deadline'] = params["deadline"].to_d
		end
		o.set_student_attributes(eid, attributes)
	end

	def self.has_group?(paragraph)
		[0, 1].member? paragraph
	end
	
	def self.init_group(o, eid, paragraph)
		attributes = o.get_group_attributes(eid)
		case paragraph
		when 0,1
		end
		o.set_group_attributes(eid, attributes)
	end
	
	def self.fix_group(o, eid, paragraph, attributes)
		attributes = attributes.dup
		case paragraph
		when 0,1
		end
		attributes
	end
	
	def self.render_group(o, eid, paragraph, tmpl)
		attributes = fix_group(o, eid, paragraph, o.get_group_attributes(eid))
		case paragraph
		when 0,1
			dselect = { :options => [], :value => attributes['monitor'] }
			monitor_data(o, eid, paragraph, attributes) { |*args| dselect[:options] << args }
			tmpl.monitor = dselect
		end
	end
	
	def self.save_group(o, eid, paragraph, params)
		attributes = o.get_group_attributes(eid)
		case paragraph
		when 0,1
			attributes['monitor'] = params["monitor"].to_i
		end
		o.set_group_attributes(eid, attributes)
	end
	def self.monitor_data(o, eid, paragraph, attributes)

					$sql.execute("SELECT student_id, first_name, last_name, father_name FROM student WHERE group_id=#{eid} ORDER BY last_name, first_name, father_name").fetch { |row|
						yield row['student_id'].to_i, "#{row['last_name']} #{row['first_name']} #{row['father_name']}"
					}

	end

end
